# 积分余额实时更新实现文档

## 阶段一：后端推送与轮询接口开发

### 1. WebSocket服务端实现

我们创建了`server/websocket.js`文件，实现了以下功能：

- 基于`ws`库的WebSocket服务器
- 用户通过JWT Token进行身份验证
- 支持多个客户端同时连接
- 连接成功后立即推送当前积分余额
- 提供`sendUserBalance`函数，用于在积分变动时推送最新余额
- 支持心跳检测，保持连接活跃
- 连接断开时自动清理资源

WebSocket连接URL格式：`ws://服务器地址:端口?token=用户JWT令牌`

### 2. SSE（Server-Sent Events）服务端实现

我们在`server/routes/credits.js`中添加了SSE端点：`/api/credits/sse`，实现了以下功能：

- 设置正确的响应头：`Content-Type: text/event-stream`
- 用户通过JWT Token进行身份验证
- 连接成功后立即推送当前积分余额
- 提供`sendBalanceSSE`函数，用于在积分变动时推送最新余额
- 定期发送ping消息，保持连接活跃
- 连接断开时自动清理资源

SSE连接URL格式：`/api/credits/sse`（需要在请求头中包含Authorization: Bearer 令牌）

### 3. 轮询接口实现

我们添加了两个轮询接口：

- `/api/credits/balance`：原有的积分余额查询接口
- `/api/credits/balance/poll`：专为轮询优化的接口，包含额外的元数据

这两个接口都需要JWT Token进行身份验证，并返回相同的积分数据结构。

### 4. 统一的推送机制

我们创建了`notifyBalanceUpdate`函数，它会：

- 同时调用WebSocket和SSE的推送函数
- 在所有积分变动的地方（如购买、消费、管理员调整等）都会触发推送
- 确保用户能够及时收到最新的积分余额

### 5. 测试工具

为了方便测试和验证实时推送功能，我们创建了以下测试脚本：

- `server/test-websocket.js`：测试WebSocket连接和消息接收
  ```
  node test-websocket.js <JWT令牌>
  ```

- `server/test-sse.js`：测试SSE连接和事件接收
  ```
  node test-sse.js <JWT令牌>
  ```

- `server/test-polling.js`：测试轮询接口
  ```
  node test-polling.js <JWT令牌>
  ```

- `server/simulate-credit-change.js`：模拟积分变动，触发实时推送
  ```
  node simulate-credit-change.js <JWT令牌> <用户ID> <积分变动量>
  ```

这些测试工具可以帮助我们验证三种连接方式的正确性和稳定性。

## 后续步骤

### 阶段二：前端多级连接逻辑实现

- 实现前端的WebSocket连接逻辑
- 实现前端的SSE连接逻辑
- 实现前端的轮询逻辑
- 实现断线重连和降级机制
- 实现全局积分状态管理

### 阶段三：后端推送触发点与事件发布

- 在多实例部署时，考虑使用Redis Pub/Sub或消息队列
- 优化推送性能，避免频繁推送
- 添加推送失败的重试机制

### 阶段四：测试与优化

- 测试三种连接模式的性能和稳定性
- 模拟异常场景，验证降级逻辑
- 监控推送与轮询接口的性能
- 优化服务器资源使用 